{"mappings":"AAAA,SAAS,gBAAgB,CAAC,oBAAoB;IAE1C,IAAI,SAAS,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAmPZ,CAAC;IACH,SAAS,cAAc,CAAC,aAAa,SAAS,GAAG;AAErD","sources":["functions/fn_script.js"],"sourcesContent":["document.addEventListener('DOMContentLoaded', function() {\r\n    \r\n    var logfun = `\r\n<span class=\"sub-head\">Function declaration </span>\r\n<div class=\"code\"> \r\n    function logger(a,b){\r\n        console.log(a, b);\r\n        let s = \\`I am having \\${a} and \\${b} in my hand \\';\r\n        return s;\r\n    }\r\n    console.log(logger('apples', 'oranges'));\r\n    // return will not return a value unless it is console.log\r\n</div>\r\n<div class=\"code\"> \r\n    function logg(a,b){\r\n        console.log(a, b);\r\n        let s = \\`I am having \\${a} and \\${b} in my hand \\`;\r\n        return s;\r\n    }\r\n    var cal = logg(\"apple\", \"orange\");\r\n    console.log(cal); \r\n</div>\r\n<span class=\"sub-head\">Function expression</span>\r\n<div class=\"code\"> \r\n    var calc = function (year){ \r\n    //ananonymous fucntion - a fn without a name \r\n        return 2024 - year;\r\n    }\r\n    console.log(calc(1998));\r\n</div>\r\nThe difference between function delaration and function expression way of calling the function is, \r\nwe can call the function before defining it, in the function definition way but not in function expresion. \r\nDoing so in finction expression will <span class = \"code-word\">\"Cannot access before intialization\"</span> error.\r\n\r\n<span class = \"sub-head\">Arrow Function </span>\r\n<div class = \"code\">\r\n    var age = byear => 2024 - byear;\r\n    console.log(age(1998));\r\n</div>\r\nArrow function doesn't need code block{} and no return statement(for one line code) as it is implicitily done. \r\nlets say we have to find <span class = \"code-word\">yearsUntilRetirement</span> then 1st we have to find age and then <span class = \"code-word\">retirement_age - age</span>. \r\nIn this case we have to use {} and return statement even if it is arrow function\r\n\r\nUnlike regular function, Arrow functions doesnot have its own <span class=\"code-word\">this</span> keyword. \r\nMeaning if,<span class=\"code-word\"> this</span> keyword is used in arrow function it actually inherits the parent object - either an function inside which it is used or global <span class=\"code-word\">DOM window</span> object.\r\n<div class = \"code\">\r\n    var yearsUntilRetirement = byear => {\r\n    let age = 2024 - byear;\r\n    let years = 60 - age;\r\n    return years;\r\n    }\r\n    console.log(yearsUntilRetirement(1998));\r\n</div>\r\n<span class=\"sub-head\">Function calling other function</span>\r\n<div class = \"code\"> \r\n    function piece(n){\r\n    return n * 5;\r\n    }\r\n    function fruitProcess(a,b){\r\n        let applePiece =  piece(a);\r\n        let orangePiece = piece(b);\r\n        let s = \\`I am having \\${applePiece} pieces of apple and \\${orangePiece} pieces of orange in my hand\\`;\r\n        return s;\r\n    }\r\n    console.log(fruitProcess(2, 3)); \r\n</div>\r\n<span class = \"sub-head\">REST Operator in functions</span>\r\n<div class = 'code'>\r\n    const add = function(...num){\r\n    let sum = 0;\r\n    for(let i in num){\r\n        sum = sum + num[i];\r\n    }\r\n    console.log(sum);\r\n    }\r\n\r\n    const x = [3,5,6]\r\n    add(2,3); // 5\r\n    add(5,6,7,7); //25\r\n    add(765,4444,666,33,2,1,4,9); //5924\r\n    add(...x); //14\r\n</div>\r\n<span class = \"sub-head\">Default parameter</span>\r\nWe can provide default values for  the params passed to teh function in case if they are not defined on function call.\r\nThis feature is introduces from ES6 version\r\nHow can we do that? Here is an example\r\n<div class ='code'>\r\n    const sum = function (a=1, b=1){\r\n        return a + b;\r\n    }\r\n    console.log(sum());\r\n</div>\r\n<span class = 'sub-head'>Call back Function </span>\r\nFunction calling another fucntion is callled callback function. The calling function is called Higher-order function.\r\n<div class =  'code'>\r\n    function oneWord (s) {\r\n        return s.replace(/ /g, '').toLowerCase();\r\n    };\r\n\r\n    function transform (str, fn){\r\n        console.log(\\`Transformed string: \\${fn(str)}\\`);\r\n        console.log(\\`Transformed by : \\${fn.name}\\`); \\\\returns the function name being passed here \r\n    }\r\n\r\n    transform(\"I'm learning JS\", oneWord);\r\n</div>\r\n<span class = 'sub-head'>Function returning functions </span>\r\n<div class = 'code'>\r\n    function greet (gr){\r\n        return function (name){\r\n            console.log(\\`\\${gr}, \\${name}\\`);\r\n        }\r\n    }\r\n    const greets = greet('Hey');\r\n    greets('Lakshmi');                --->Method 1\r\n\r\n    greet('Hello')('Lakshmi');     --->Method 2\r\n</div> \r\nFor arrow function\r\n<div class = 'code'>\r\n    const greets = gr => n => console.log(\\`\\${gr}, \\${n}\\`) ;\r\n    greets('Hi')('Lakshmi');\r\n</div>\r\n<span class = 'sub-head'>Methods to borrow functions inside an object by another object </span>\r\n\r\n<span class = 'sub-sub-head'>&#128640; CALL method </span>\r\nCall method for a fucntion is udef when we have more then one function calling the same method \r\nfor different purpose and that method has <span class = 'code-word'> this </span> keyword to refer to the paramenters.\r\n\r\nIn this case, while we have multiple function call a method, <span class = 'code-word'> this </span> keyword dont know which function to point and result in error.\r\n\r\nTo avoid this we use call method on the method.\r\n<div class = 'code'>\r\n    travellingme ={\r\n        fcode: 'LH',\r\n        bookings :[],\r\n        book (flight, num, fname = 'Lakshmi'){\r\n            console.log(\\`Hey, \\${fname} is travelling on \\${flight}\r\n                flight \\${this.fcode}\\${num}\\`)\r\n            //this.bookings.push (\\`\\${this.fcode}\\${num}\\`, fname)    --->  bookings: [ 'LH234', 'Lakshmi', 'LH446', 'Lakshmi' ],\r\n            this.bookings.push({flight :\\`\\${this.fcode}\\${num}\\`, fname}) \r\n                                                                // ---> bookings: [\r\n                                                                //{ flight: 'LH234', name: 'Lakshmi' },\r\n                                                                //{ flight: 'LH678', name: 'Lakshmi' }\r\n                                                                // ],\r\n        }\r\n    }\r\n    travellingme.book('Air Asia', 234,);\r\n    travellingOther = {\r\n        fcode : 'AB',\r\n        bookings : [],\r\n\r\n    }\r\n    const book = travellingme.book;\r\n    book.call(travellingOther, 'Lufth', 777, 'John');\r\n    book.call(travellingme, 'ESA', 446 );\r\n    console.log(\"me\",travellingme); \r\n    console.log(\"other\",travellingOther);\r\n</div>  \r\n<span class = 'sub-sub-head'>&#128640; BIND method</span>\r\nOther way of defining for this keyword  is .BIND() . This method allows you to explicitly set 2nd object to the calling method in 1st object.\r\n<div class = 'code'>\r\n    travellingme ={\r\n        fcode: 'LH',\r\n        bookings :[],\r\n        book (flight, num, fname = 'Lakshmi'){\r\n            console.log(\\`Hey, \\${fname} is travelling on \\${flight}\r\n                flight \\${this.fcode}\\${num}\\`)\r\n            //this.bookings.push (\\`\\${this.fcode}\\${num}\\`, fname)    --->  bookings: [ 'LH234', 'Lakshmi', 'LH446', 'Lakshmi' ],\r\n            this.bookings.push({flight :\\`\\${this.fcode}\\${num}\\`, fname}) \r\n                                                                // ---> bookings: [\r\n                                                                //{ flight: 'LH234', name: 'Lakshmi' },\r\n                                                                //{ flight: 'LH678', name: 'Lakshmi' }\r\n                                                                // ],\r\n        }\r\n    }\r\n    \r\n    travellingOther = {\r\n        fcode : 'AB',\r\n        bookings : [],\r\n\r\n    }\r\n\r\n    const bookOther = travellingme.book.bind(travellingOther);  // here this keyword will always point to travellingOther object\r\n    bookOther('ABC', 778, 'Steve');\r\n    console.log(\"other\",travellingOther);\r\n    \r\n    const bookOther78 = book.bind(travellingOther,'ABC' ,778);\r\n    bookOther78( 'Martha');\r\n    bookOther78('Sara'); // with bind we can use bookOther78 multimple times \r\n    //like here for different user on same flight\r\n</div>\r\n    <i>Another example for <b> call/apply/bind method </b> </i>\r\n<ul><li>call attaches this into function and executes the function immediately:\r\n<div class = 'code'>\r\n    var person = {  \r\n    name: \"James Smith\",\r\n    hello: function(thing) {\r\n        console.log(this.name + \" says hello \" + thing);\r\n        }\r\n    }\r\n    person.hello(\"world\");  // output: \"James Smith says hello world\"\r\n    person.hello.call({ name: \"Jim Smith\" }, \"world\"); // output: \"Jim Smith says hello world\"\r\n</div></li>\r\n<li>bind attaches this into function and it needs to be invoked separately like this:\r\n<div class = 'code'>\r\nvar person = {  \r\n  name: \"James Smith\",\r\n  hello: function(thing) {\r\n    console.log(this.name + \" says hello \" + thing);\r\n  }\r\n}\r\n\r\nperson.hello(\"world\");  // output: \"James Smith says hello world\"\r\nvar helloFunc = person.hello.bind({ name: \"Jim Smith\" });\r\nhelloFunc(\"world\");  // output: Jim Smith says hello world\"\r\n\r\nor like this:\r\n    \r\nvar helloFunc = person.hello.bind({ name: \"Jim Smith\" }, \"world\");\r\nhelloFunc();  // output: Jim Smith says hello world\"\r\n</div></li>\r\n<li>apply is similar to call except that it takes an array-like object instead of listing the arguments out one at a time:\r\n<div class = 'code'>\r\nfunction personContainer() {\r\n  var person = {  \r\n     name: \"James Smith\",\r\n     hello: function() {\r\n       console.log(this.name + \" says hello \" + arguments[1]);\r\n     }\r\n  }\r\n  person.hello.apply(person, arguments);\r\n}\r\npersonContainer(\"world\", \"mars\"); // output: \"James Smith says hello mars\", note: arguments[0] = \"world\" , arguments[1] = \"mars\" \r\n</div></li></ul>\r\n<span class = 'sub-head'>Immediately Invoked Function Expressions (IIFE) </span>\r\nFunctions that are executed immediately after they are defined. They are typically used to create a local scope for variables to prevent them from polluting the global scope.\r\nThey are used to create private scope in JavaScript, allowing variables and functions to be encapsulated and inaccessible from outside the function.\r\n<div class = 'code'>\r\n    (function(){\r\n        console.log(\"Private Immediately Invoked Function Expressions (IIFE)\")\r\n    })();\r\n\r\n    //Arrow function IIFE\r\n    (() => console.log(\"Private Immediately Invoked Function Expressions (IIFE)  for Arrow FUnction\"))();\r\n</div>`\r\n    document.getElementById(\"functions\").innerHTML = logfun;\r\n\r\n})\r\n"],"names":[],"version":3,"file":"index.ab982f21.js.map","sourceRoot":"/__parcel_source_root/"}